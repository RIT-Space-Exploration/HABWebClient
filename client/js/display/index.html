<!DOCTYPE html>
<html lang="en">
<head>
<title>CubeSat Visualization - RIT SPEX - ImagineRIT 2017</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
body {
	font-family: Monospace;
	background-color: #f0f0f0;
	margin: 0px;
	overflow: hidden;
}
</style>
</head>

<body background="space.JPG" style="background-size:cover">
<canvas id="debug" style="position:absolute; left:100px"></canvas>



<script>
'use strict';
</script>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script type="text/javascript" src="loaders/ColladaLoader.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="http://code.jquery.com/jquery-1.11.1.js"></script>
<script>
	DATA= {x:0.0, y:0.0, z:0.0};
	var socket = io();

	socket.on('toClient', function(data) {
		console.log(data);
		DATA.x = data.x;
		DATA.y = data.y;
		DATA.z = data.z;
		console.log(DATA);
	});
</script>

<script>
// From d3-threeD.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

function d3threeD(exports) {

const DEGS_TO_RADS = Math.PI / 180, UNIT_SIZE = 100;

const DIGIT_0 = 48, DIGIT_9 = 57, COMMA = 44, SPACE = 32, PERIOD = 46, MINUS = 45;

exports.transformSVGPath =
function transformSVGPath(pathStr) {
	var path = new THREE.ShapePath();

	var idx = 1, len = pathStr.length, activeCmd,
		x = 0, y = 0, nx = 0, ny = 0, firstX = null, firstY = null,
		x1 = 0, x2 = 0, y1 = 0, y2 = 0,
		rx = 0, ry = 0, xar = 0, laf = 0, sf = 0, cx, cy;

	function eatNum() {
		var sidx, c, isFloat = false, s;
		// eat delims
		while (idx < len) {
			c = pathStr.charCodeAt(idx);
			if (c !== COMMA && c !== SPACE)
				break;
			idx++;
		}
		if (c === MINUS)
			sidx = idx++;
		else
			sidx = idx;
		// eat number
		while (idx < len) {
			c = pathStr.charCodeAt(idx);
			if (DIGIT_0 <= c && c <= DIGIT_9) {
				idx++;
				continue;
			}
			else if (c === PERIOD) {
				idx++;
				isFloat = true;
				continue;
			}

			s = pathStr.substring(sidx, idx);
			return isFloat ? parseFloat(s) : parseInt(s);
		}

		s = pathStr.substring(sidx);
		return isFloat ? parseFloat(s) : parseInt(s);
	}

	function nextIsNum() {
		var c;
		// do permanently eat any delims...
		while (idx < len) {
			c = pathStr.charCodeAt(idx);
			if (c !== COMMA && c !== SPACE)
				break;
			idx++;
		}
		c = pathStr.charCodeAt(idx);
		return (c === MINUS || (DIGIT_0 <= c && c <= DIGIT_9));
	}

	var canRepeat;
	activeCmd = pathStr[0];
	while (idx <= len) {
		canRepeat = true;
		switch (activeCmd) {
			// moveto commands, become lineto's if repeated
			case 'M':
				x = eatNum();
				y = eatNum();
				path.moveTo(x, y);
				activeCmd = 'L';
				firstX = x;
				firstY = y;
				break;
			case 'm':
				x += eatNum();
				y += eatNum();
				path.moveTo(x, y);
				activeCmd = 'l';
				firstX = x;
				firstY = y;
				break;
			case 'Z':
			case 'z':
				canRepeat = false;
				if (x !== firstX || y !== firstY)
					path.lineTo(firstX, firstY);
				break;
			// - lines!
			case 'L':
			case 'H':
			case 'V':
				nx = (activeCmd === 'V') ? x : eatNum();
				ny = (activeCmd === 'H') ? y : eatNum();
				path.lineTo(nx, ny);
				x = nx;
				y = ny;
				break;
			case 'l':
			case 'h':
			case 'v':
				nx = (activeCmd === 'v') ? x : (x + eatNum());
				ny = (activeCmd === 'h') ? y : (y + eatNum());
				path.lineTo(nx, ny);
				x = nx;
				y = ny;
				break;
			// - cubic bezier
			case 'C':
				x1 = eatNum(); y1 = eatNum();
			case 'S':
				if (activeCmd === 'S') {
					x1 = 2 * x - x2; y1 = 2 * y - y2;
				}
				x2 = eatNum();
				y2 = eatNum();
				nx = eatNum();
				ny = eatNum();
				path.bezierCurveTo(x1, y1, x2, y2, nx, ny);
				x = nx; y = ny;
				break;
			case 'c':
				x1 = x + eatNum();
				y1 = y + eatNum();
			case 's':
				if (activeCmd === 's') {
					x1 = 2 * x - x2;
					y1 = 2 * y - y2;
				}
				x2 = x + eatNum();
				y2 = y + eatNum();
				nx = x + eatNum();
				ny = y + eatNum();
				path.bezierCurveTo(x1, y1, x2, y2, nx, ny);
				x = nx; y = ny;
				break;
			// - quadratic bezier
			case 'Q':
				x1 = eatNum(); y1 = eatNum();
			case 'T':
				if (activeCmd === 'T') {
					x1 = 2 * x - x1;
					y1 = 2 * y - y1;
				}
				nx = eatNum();
				ny = eatNum();
				path.quadraticCurveTo(x1, y1, nx, ny);
				x = nx;
				y = ny;
				break;
			case 'q':
				x1 = x + eatNum();
				y1 = y + eatNum();
			case 't':
				if (activeCmd === 't') {
					x1 = 2 * x - x1;
					y1 = 2 * y - y1;
				}
				nx = x + eatNum();
				ny = y + eatNum();
				path.quadraticCurveTo(x1, y1, nx, ny);
				x = nx; y = ny;
				break;
			// - elliptical arc
			case 'A':
				rx = eatNum();
				ry = eatNum();
				xar = eatNum() * DEGS_TO_RADS;
				laf = eatNum();
				sf = eatNum();
				nx = eatNum();
				ny = eatNum();
				if (rx !== ry) {
					console.warn("Forcing elliptical arc to be a circular one :(",
						rx, ry);
				}
				// SVG implementation notes does all the math for us! woo!
				// http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
				// step1, using x1 as x1'
				x1 = Math.cos(xar) * (x - nx) / 2 + Math.sin(xar) * (y - ny) / 2;
				y1 = -Math.sin(xar) * (x - nx) / 2 + Math.cos(xar) * (y - ny) / 2;
				// step 2, using x2 as cx'
				var norm = Math.sqrt(
					 (rx*rx * ry*ry - rx*rx * y1*y1 - ry*ry * x1*x1) /
					 (rx*rx * y1*y1 + ry*ry * x1*x1));
				if (laf === sf)
					norm = -norm;
				x2 = norm * rx * y1 / ry;
				y2 = norm * -ry * x1 / rx;
				// step 3
				cx = Math.cos(xar) * x2 - Math.sin(xar) * y2 + (x + nx) / 2;
				cy = Math.sin(xar) * x2 + Math.cos(xar) * y2 + (y + ny) / 2;

				var u = new THREE.Vector2(1, 0),
					v = new THREE.Vector2((x1 - x2) / rx,
					                      (y1 - y2) / ry);
				var startAng = Math.acos(u.dot(v) / u.length() / v.length());
				if (u.x * v.y - u.y * v.x < 0)
					startAng = -startAng;

				// we can reuse 'v' from start angle as our 'u' for delta angle
				u.x = (-x1 - x2) / rx;
				u.y = (-y1 - y2) / ry;

				var deltaAng = Math.acos(v.dot(u) / v.length() / u.length());
				// This normalization ends up making our curves fail to triangulate...
				if (v.x * u.y - v.y * u.x < 0)
					deltaAng = -deltaAng;
				if (!sf && deltaAng > 0)
					deltaAng -= Math.PI * 2;
				if (sf && deltaAng < 0)
					deltaAng += Math.PI * 2;

				path.absarc(cx, cy, rx, startAng, startAng + deltaAng, sf);
				x = nx;
				y = ny;
				break;
			default:
				throw new Error("weird path command: " + activeCmd);
		}
		// just reissue the command
		if (canRepeat && nextIsNum())
			continue;
		activeCmd = pathStr[idx++];
	}

	return path;
}
}

var $d3g = {};
d3threeD($d3g);
</script>



<script>
/// Part from g0v/twgeojson
/// Graphic Engine and Geo Data Init Functions

var addGeoObject = function( group, svgObject ) {
	var i,j, len, len1;
	var path, mesh, color, material, amount, simpleShapes, simpleShape, shape3d, x, toAdd, results = [];
	var thePaths = svgObject.paths;
	var theAmounts = svgObject.amounts;
	var theColors = svgObject.colors;
	var theCenter = svgObject.center;

	len = thePaths.length;
	for (i = 0; i < len; ++i) {
		path = $d3g.transformSVGPath( thePaths[i] );
		color = new THREE.Color( theColors[i] );
		material = new THREE.MeshLambertMaterial({
			color: color,
			emissive: color
		});
		amount = theAmounts[i];
		simpleShapes = path.toShapes(true);
		len1 = simpleShapes.length;
		for (j = 0; j < len1; ++j) {
			simpleShape = simpleShapes[j];
			shape3d = new THREE.ExtrudeGeometry( simpleShape,{ amount: amount, bevelEnabled: false });
			mesh = new THREE.Mesh(shape3d, material);
			mesh.rotation.x = 0;
			mesh.rotation.y = 0;
			mesh.rotation.z = 0;
			mesh.translateZ( 0);
			mesh.translateX( - theCenter.x);
			mesh.translateY( - theCenter.y);
			group.add(mesh);
		}
	}
};


var init3d = function(){

	/// Global : renderer
	renderer = new THREE.WebGLRenderer( { alpha:true, antialias: true } );
	renderer.setClearColor( 0x000000, 0);
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );

	/// Global : scene
	scene = new THREE.Scene();

	/// Global : camera
	camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 0.01, 5000 );
	camera.position.set( 0, 0, 200 );

	/// Global : group
	group1 = new THREE.Group();
	//scene.add( group1 );
	group2 = new THREE.Group();
	//scene.add( group2 );
	group3 = new THREE.Group();

	//var loader = new THREE.ObjectLoader();
	//loader.load("lambo-json/lambo.json", function( obj ) {
		//var meshLambo = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
	//	obj.scale.set(35,35,35);
	//	group3.add( obj );
	//	scene.add( group3 );
	//});
	console.log(scene);

	var loader = new THREE.ColladaLoader();
	loader.options.convertUpAxis = true;
	loader.load("cubesat.dae", function( collada ) {
		dae = collada.scene;
		dae.traverse( function ( child ) {
			if ( child instanceof THREE.Mesh ) {
				child.material.color.setHex('0xff7b00');
			}
		});
		dae.scale.set(1000,1000,1000);
		dae.updateMatrix();
		group3.add( dae );
		scene.add( group3 );
	});

	/// direct light
	var light = new THREE.DirectionalLight( 0x404040 );
	light.position.set( 0.75, 0.75, 1.0 ).normalize();
	scene.add( light );

	/// ambient light
	var ambientLight = new THREE.AmbientLight(0x404040);
	scene.add( ambientLight );


	//var objs = initSVGObject();
	//addGeoObject( group1, objs[0] );
	//addGeoObject( group2, objs[1] );
	//group2.x = Math.PI;
};

var initSVGObject = function() {
	var obj1 = {};

	obj1.paths = [
				"M98.79 3.67C102.81 3.67 106.08 6.93 106.08 10.96C106.08 30.07 106.08 80.13 106.08 99.24C106.08 103.27 102.81 106.53 98.79 106.53C79.67 106.53 29.62 106.53 10.5 106.53C6.48 106.53 3.21 103.27 3.21 99.24C3.21 80.13 3.21 30.07 3.21 10.96C3.21 6.93 6.48 3.67 10.5 3.67C29.62 3.67 79.67 3.67 98.79 3.67Z"];

	obj1.amounts = [ 45 ];
	obj1.colors =  [ 0xC07000 ];
	obj1.center = { x:55, y:55 };

	var obj2 = {};

	obj2.paths = [
				"M98.79 3.67C102.81 3.67 106.08 6.93 106.08 10.96C106.08 30.07 106.08 80.13 106.08 99.24C106.08 103.27 102.81 106.53 98.79 106.53C79.67 106.53 29.62 106.53 10.5 106.53C6.48 106.53 3.21 103.27 3.21 99.24C3.21 80.13 3.21 30.07 3.21 10.96C3.21 6.93 6.48 3.67 10.5 3.67C29.62 3.67 79.67 3.67 98.79 3.67Z"];

	obj2.amounts = [ 45 ];
	obj2.colors =  [ 0xC07000 ];
	obj2.center = { x:55, y:55 };

	return [obj1,obj2];
};
</script>



<script>
	/// Events from extrude shapes example

	function onWindowResize() {

		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function onDocumentMouseDown( event ) {
		event.preventDefault();
	}


	function onDocumentTouchStart( event ) {
		event.preventDefault();
	}

	function onDocumentTouchMove( event ) {
		event.preventDefault();
	}

	function animate() {

		/// compatibility : http://caniuse.com/requestanimationframe
		requestAnimationFrame( animate );

		render();
	}

	function render() {
		group3.rotation.x = DATA.x;
		group3.rotation.y = DATA.y;
		group3.rotation.z = DATA.z;

		renderer.render( scene, camera );
	}
</script>



<script>
	/// Main

	var renderer, stats;
	var scene, camera, group;

	var targetRotation = 0;
	var targetRotationOnMouseDown = 0;

	var mouseX = 0;
	var mouseXOnMouseDown = 0;

	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;

	var container = document.createElement( 'div' );
	document.body.appendChild( container );

	var info = document.createElement( 'div' );
	info.style.position = 'absolute';
	info.style.top = '10px';
	info.style.width = '100%';
	info.style.textAlign = 'center';
	info.innerHTML = 'CubeSat Visualization';
	container.appendChild( info );

	init3d();
	// initBackground();
	container.appendChild( renderer.domElement );

	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	document.addEventListener( 'touchstart', onDocumentTouchStart, false );
	document.addEventListener( 'touchmove', onDocumentTouchMove, false );
	window.addEventListener( 'resize', onWindowResize, false );

	group1.rotation.x = 0.5*Math.PI;
	group2.rotation.x = 1.5*Math.PI;
	animate();
</script>


</body>
</html>
